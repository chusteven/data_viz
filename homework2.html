<!DOCTYPE html>
<html lang="en">

<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">

<title>MSAN 622 Information Visualization</title>

<link href="css/bootstrap.min.css" rel="stylesheet">
<link href="css/bootstrap-theme.min.css" rel="stylesheet">

<style type="text/css">
    body {
        padding-top: 50px;
        padding-bottom: 20px;
    }
</style>


</head>

<body>

<!-- this is defining the style for the objects we will have populating our page -->
<style>

/* for bubble plots */
svg#bp .text{
    font: 10px sans-serif;
}

svg#bp .dot {
  stroke: #000;
  opacity: 0.8;
}

svg#bp .axis {
  font: 12px sans-serif;
}

svg#bp .axis path, .axis line {
  fill: none;
  stroke: #000;
  shape-rendering: crispEdges;
}

svg#bp .label {
  fill: #777;
}


/* for scatter plots */
svg#sp {
  font: 10px sans-serif;
  padding: 10px;
}

svg#sp .axis,
.frame {
  shape-rendering: crispEdges;
}

svg#sp .axis line {
  stroke: #ddd;
}

svg#sp .axis path {
  display: none;
}

svg#sp .frame {
  fill: none;
  stroke: #aaa;
}

svg#sp circle {
  fill-opacity: .7;
}


/* for parallel plots */
svg#pp {
  font: 12px sans-serif;
}

svg#pp .background path {
  fill: none;
  stroke: none;
  stroke-width: 20px;
  pointer-events: stroke;
}

svg#pp .foreground path {
  fill: none;
  stroke: steelblue;
  stroke-width: 1.5px;
}

svg#pp .axis .title {
  font-size: 11px;
  font-weight: bold;
  text-transform: uppercase;
}

svg#pp .axis line, .axis path {
  fill: none;
  stroke: #000;
  shape-rendering: crispEdges;
}

svg#pp .axis.string {
  font-size: 6px;
}

svg#pp .label {
  -webkit-transition: fill 125ms linear;
}

svg#pp .active .label:not(.inactive) {
  font-weight: bold;
  font-size: 11px;
}

svg#pp .label.inactive {
  fill: #ccc;
}

svg#pp .foreground path.inactive {
  stroke: #ccc;
  stroke-opacity: .5;
  stroke-width: 1px;
}

</style>

<nav class="navbar navbar-inverse navbar-fixed-top">
    <div class="container">
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
                <span class="sr-only">Toggle Navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="#">MSN 622</a>
        </div>

        <div id="navbar" class="navbar-collapse collapse">
            <ul class="nav navbar-nav">
                <li><a href="#homework">Homework</a></li>
                <li><a href="#project">Project</a></li>
                <li><a href="#participation">Participation</a></li>
            </ul>

            <ul class="nav navbar-nav navbar-right">
                <li><a href="#about">About</a></li>
                <li><a href="#contact">Contact</a></li>
            </ul>
        </div>
    </div>
</nav>

<div class="container">

    <!-- title for homework -->
    <div class="row" style="text-align:center;">
        <h1>Homework 2: A Few Other Charts</h1>
        <p>This page is for Steven Chu's second MSAN 622 homework assignment. Source code can be found in my <a href="https://github.com/chusteven/spring-2015-msan622">github respository</a>.</p>
    </div>

    <!-- bubble plot chart -->
    <div class="row">
        <h2>A Bubble Plot</h2>

        <p>For C-level functionality:</p>

        <ul>
            <li>Each bubble represents a state</li>
            <li>The size of the bubble represents that state's population size</li>
            <br>
            <li>NB: would like to add a border around legend</li>
            <li>NB: would like to add another legend so as to show population size comparisons</li>
            <li>NB: would like to add tooltip to show exact values for each state on mouseover</li>
        </ul>

        <div class="media-body" id="bubblePlot"></div>

    </div>

    <!-- scatter plot chart -->
    <div class="row">
        <h2>A Scatterplot</h2>

        <p>For B-level functionality:</p>

        <ul>
            <li>I'm plotting all numerical features (except frost and area) against each other</li>
            <li>The colors represent the four different regions of the USA</li>
            <li>The diagonal represents the distribution of each variable</li>
            <br>
            <li>NB: somehow x-axis values aren't showing up properly</li>
            <li>NB: graphic object is somehow messed up, making it so circles go off plottable area</li>
            <li>NB: would like to more properly name features along each axis</li>
            <li>NB: would like to reintroduce brushing option</li>
        </ul>

        <div class="media-body" id="scatterPlot"></div>

    </div>

    <!-- parallel coordinates plot -->
    <div class="row">
        <h2>A Parallel Coordinates Plot</h2>

        <p>For A-level functionality:</p>

        <ul>
            <li>Can trace each of the 50 states numerical features</li>
            <li>Can highlight one state's values at a time</li>
            <br>
            <li>NB: somehow can't mouseover state names (like in tutorial)</li>
            <li>NB: would like to more properly name features along each axis</li>
            <li>NB: would like to take a stab at the more advanced parallel plot</li>
        </ul>

        <div class="media-body" id="parallelPlot"></div>

    </div>    

</div>

<div class="container">

    <div class="media-body" id="explanation">
        <!-- this is where my discussion goes -->
        <h1 class="page-header">Discussion</h1>

        <p>For this assignment, I didn't quite have as much functionality as I might have wished. In general, I wanted to focus on making it so that users could have easier access to the exact values they were looking at. That said, I would like to introduce tooltips to at least the first and third visualization. For the second and third visualizations, additionally, I would like to introduce brushing options so the user can investigate specific subsamples of the data as they please.</p>

        <p>Where possible, I chose to subset my data by region. Representing this by color would, I thought, be a simple way of comparing across various regions the other metrics represented. For the bubble chart, I chose to represent these data points as circles because that allows us to compare across various population values. For the scatterplot, introducing the diagonal allowed me to show the various distributions of values for each feature. For the parallel coordinates chart, I specifically wanted the states on the left size for ease of access to their data.</p>

    </div>

</div>


<footer>
    <p style="text-align: center;">Steven Chu &bullet; MSAN 622 Information Visualization &bullet; Spring 2015</p>
</footer>

</div>

<script src="js/jquery.min.js"></script>
<script src="js/bootstrap.min.js"></script>
<script src="js/d3.min.js"></script>

<!-- here is where all my Javascript goes -->
<script>

    // need to make a bubble plot!
    // http://chimera.labs.oreilly.com/books/1230000000345/ch06.html#_the_scatterplot (decent)
    // http://bost.ocks.org/mike/nations/ (better)
    // http://bost.ocks.org/mike/bar/3/

    
    // various accessors that specify the four dimensions of data to visualize.
    function cx(d) { return d["Income"]; } // for specifying x-center of the bubble
    function cy(d) { return d["Life.Exp"]; } // for specifying y-center of the bubble
    function radius(d) { return d["Population"]; } // for specifying radius of the bubble
    function color(d) { return d["state.region"]; } // for specifying color the buble
    function key(d) { return d["state.name"]; } // for grabbing the name of the state
    function order(a, b) { return radius(b) - radius(a); } // for sorting the bubbles by size

    // chart dimensions (try changing these)
    var bubbleMargin = {top: 20, right: 20, bottom: 30, left: 40},
        bubbleWidth = 1000 - bubbleMargin.left - bubbleMargin.right,
        bubbleHeight = 600 - bubbleMargin.top - bubbleMargin.bottom;


    // creating x, y, radius, color scaling functions
    // question: is there a lie factor happening right here?
    // note: the population is the input x, ideally would be reflected in something like a straight line
    // note: but it is getting transformed to an area ... so lie factor is by squared times pi factor, i think (?)
    var xScale = d3.scale.linear().range([0, bubbleWidth]),
        yScale = d3.scale.linear().range([bubbleHeight, 0]),
        radiusScale = d3.scale.sqrt().range([0, 10]), // ask myself why 10? is there a programmatic way to do this?
        colorScale = d3.scale.category10();

    // creating x and y axes (need to modify tick frequency as well as format)
    var xAxis = d3.svg.axis()
            .scale(xScale)
            .orient("bottom"), 
        yAxis = d3.svg.axis()
            .scale(yScale)
            .orient("left")
            .tickFormat(d3.format(",.1f"))

    // creating the bubble chart objects
    var bubbleChart = d3.select("#bubblePlot").append("svg")
        .attr("id", "bp")
        .attr("width", bubbleWidth + bubbleMargin.left + bubbleMargin.right)
        .attr("height", bubbleHeight + bubbleMargin.top + bubbleMargin.bottom)
      .append("g")
        .attr("transform", "translate(" + bubbleMargin.left + "," + bubbleMargin.top + ")");


    // reading in the data and appending the chart and then creating the actual bubbles
    d3.csv("states.csv", function(error, data) {

        // adds domain to x, y, and radius scaling functions
        xScale.domain([d3.min(data, function(d) { return cx(d)}), d3.max(data, function(d) { return cx(d)})]).nice();        
        yScale.domain([d3.min(data, function(d) { return cy(d)}), d3.max(data, function(d) { return cy(d)})]).nice();
        radiusScale.domain([0, d3.max(data, function(d) { return radius(d)})]).nice();

        bubbleChart.append("g")
          .attr("class", "x axis")
          .attr("transform", "translate(0," + bubbleHeight + ")")
          .call(xAxis);

        bubbleChart.append("g")
          .attr("class", "y axis")
          .call(yAxis);

        // add an x-axis label.
        bubbleChart.append("text")
            .attr("class", "x label")
            .attr("text-anchor", "end")
            .attr("x", bubbleWidth)
            .attr("y", bubbleHeight - 6)
            .text("income per capita (dollars)");

        // add a y-axis label.
        bubbleChart.append("text")
            .attr("class", "y label")
            .attr("text-anchor", "end")
            .attr("y", 6)
            .attr("dy", ".75em")
            .attr("transform", "rotate(-90)")
            .text("life expectancy (years)");

        // creates bubbles for each state
        bubbleChart.selectAll(".dot")
          .data(data)
        .enter().append("circle")
          .attr("class", "dot")
          .attr("cx", function(d) { return xScale(cx(d)); })
          .attr("cy", function(d) { return yScale(cy(d)); })
          .attr("r", function(d) { return radiusScale(radius(d))}) 
          .style("fill", function(d) { return colorScale(color(d))})
          .sort(order);

        var legend = bubbleChart.selectAll(".legend")
             .data(colorScale.domain())
           .enter().append("g")
             .attr("class", "legend")
             .attr("transform", function(d, i) { return "translate(0," + i * 21 + ")"; });

         // draw legend colored rectangles
         legend.append("circle")
             .attr("cx", bubbleWidth - 30)
             .attr("cy", 10)
             .attr("r", 10)
             .style("fill", colorScale);

         // draw legend text
         legend.append("text")
             .attr("x", bubbleWidth - 50)
             .attr("y", 10)
             .attr("dy", ".35em")
             .style("text-anchor", "end")
             .text(function(d) { return d; })

    })






    // for B
    // choice between scatterplot matrix or small multiples

    // scatterplot would be picking four variables and doing basically a correlation plot for each pair
    // would also showcase each state's distribution along the diagonal
    // four different xAxis and four different yAxies frequency and tick marks

    // small multiples could look at histograms
    // pick a rectangular number of features and chart them

    var scatterWidth = 960,
        scatterSize = 150,
        scatterPadding = 19.5;

    // var x = d3.scale.linear()
    var xScatter = d3.scale.linear()
        .range([scatterPadding / 2, scatterSize - scatterPadding / 2]);

    // var y = d3.scale.linear()
    var yScatter = d3.scale.linear()
        .range([scatterSize - scatterPadding / 2, scatterPadding / 2]);

    var xAxisScatter = d3.svg.axis()
        // .scale(x)
        .scale(xScatter)
        .orient("bottom")
        .ticks(5);

    var yAxisScatter = d3.svg.axis()
        // .scale(y)
        .scale(yScatter)
        .orient("left")
        .ticks(5);

    var colorScatter = d3.scale.category10();

    d3.csv("states.csv", function(error, data) {
      var domainByTrait = {},
      traits = d3.keys(data[0]).filter(function(d) { if (["region", "Frost", "Area", "state.region", 
                                                        "state.division", "state.name", "state.abb"].indexOf(d) == -1) { return d }; }),
      n = traits.length;

      traits.forEach(function(trait) {
        domainByTrait[trait] = d3.extent(data, function(d) { return +d[trait]; });
      });

      xAxisScatter.tickSize(scatterSize * n);
      yAxisScatter.tickSize(-scatterSize * n);

      var scatterPlot = d3.select("#scatterPlot").append("svg")
          .attr("id", "sp")
          .attr("width", scatterSize * n + scatterPadding)
          .attr("height", scatterSize * n + scatterPadding)
        .append("g")
          .attr("transform", "translate(" + scatterPadding + "," + (scatterPadding / 2) + ")");

      scatterPlot.selectAll(".x.axis")
          .data(traits)
        .enter().append("g")
          .attr("class", "x axis")
          .attr("transform", function(d, i) { return "translate(" + (n - i - 1) * scatterSize + ",0)"; })
          .each(function(d) { 
            // x.domain(domainByTrait[d]);
            xScatter.domain(domainByTrait[d]);
            d3.select(this).call(xAxisScatter); 
        });

      scatterPlot.selectAll(".y.axis")
          .data(traits)
        .enter().append("g")
          .attr("class", "y axis")
          .attr("transform", function(d, i) { return "translate(0," + i * scatterSize + ")"; })
          .each(function(d) {
            // y.domain(domainByTrait[d])
            yScatter.domain(domainByTrait[d])
            d3.select(this).call(yAxisScatter);
        });

      var cell = scatterPlot.selectAll(".cell")
          .data(cross(traits, traits))
        .enter().append("g")
          .attr("class", "cell")
          .attr("transform", function(d) { return "translate(" + (n - d.i - 1) * scatterSize + "," + d.j * scatterSize + ")"; })
          .each(plot);

      // console.log(cross(traits,traits))

      // titles for the diagonal.
      cell.filter(function(d) { return d.i === d.j; }).append("text")
          .attr("x", scatterPadding)
          .attr("y", scatterPadding)
          .attr("dy", ".71em")
          .text(function(d) { return d.x; });

      function plot(p) {
        var cell = d3.select(this);

        // x.domain(domainByTrait[p.x]);
        // y.domain(domainByTrait[p.y]);
        xScatter.domain(domainByTrait[p.x]);
        yScatter.domain(domainByTrait[p.y]);

        cell.append("rect")
            .attr("class", "frame")
            .attr("x", scatterPadding / 2)
            .attr("y", scatterPadding / 2)
            .attr("width", scatterSize - scatterPadding)
            .attr("height", scatterSize - scatterPadding);

        cell.selectAll("circle")
            .data(data)
          .enter().append("circle")
            // .attr("cx", function(d) { return x(d[p.x]); })
            // .attr("cy", function(d) { return y(d[p.y]); })
            .attr("cx", function(d) { return xScatter(d[p.x]); })
            .attr("cy", function(d) { return yScatter(d[p.y]); })
            .attr("r", 3)
            .style("fill", function(d) { return colorScatter(d["state.region"]); });
      }

      function cross(a, b) {
        var c = [], n = a.length, m = b.length, i, j;
        for (i = -1; ++i < n;) for (j = -1; ++j < m;) c.push({x: a[i], i: i, y: b[j], j: j});
        return c;
      }

      d3.select(self.frameElement).style("height", scatterSize * n + scatterPadding + 20 + "px");
    });






    // for A, plot parallel coordinates
    // http://bl.ocks.org/syntagmatic/4020926
    // code from http://bl.ocks.org/syntagmatic/4020926

    // defining margins for this particular graph
    var parallelMargin = {top: 30, right: 40, bottom: 20, left: 100},
        parallelWidth = 1000 - parallelMargin.left - parallelMargin.right,
        parallelHeight = 600 - parallelMargin.top - parallelMargin.bottom;

    // define dimensions that i want to plot
    var dimensions = [
      {
        name: "state.name",
        scale: d3.scale.ordinal().rangePoints([0, parallelHeight]),
        type: "string"
      },
      {
        name: "Population",
        scale: d3.scale.linear().range([parallelHeight, 0]),
        type: "number"
      },
      {
        name: "Area",
        scale: d3.scale.linear().range([parallelHeight, 0]),
        type: "number"
      },
      {
        name: "Income",
        scale: d3.scale.linear().range([parallelHeight, 0]),
        type: "number"
      },
      {
        name: "Illiteracy",
        scale: d3.scale.linear().range([parallelHeight, 0]),
        type: "number"
      },
      {
        name: "Life.Exp",
        scale: d3.scale.linear().range([parallelHeight, 0]),
        type: "number"
      },
      {
        name: "Murder",
        scale: d3.scale.linear().range([parallelHeight, 0]),
        type: "number"
      },
      {
        name: "HS.Grad",
        scale: d3.scale.linear().range([parallelHeight, 0]),
        type: "number"
      },
      {
        name: "Frost",
        scale: d3.scale.linear().range([parallelHeight, 0]),
        type: "number"
      }
    ];

    // defining x axis object
    var xScaleParallel = d3.scale.ordinal()
        .domain(dimensions.map(function(d) { return d.name; }))
        .rangePoints([0, parallelWidth]);

    // creating line function (?)
    var line = d3.svg.line()
        .defined(function(d) { return !isNaN(d[1]); });

    // creating new y axis of sorts - want to know how exactly this interfaces with everything else
    var yAxis2 = d3.svg.axis()
        .orient("left");

    // creating the parallel axes plot
    var parallelChart = d3.select("#parallelPlot").append("svg")
        .attr("id", "pp")
        .attr("width", parallelWidth + parallelMargin.left + parallelMargin.right)
        .attr("height", parallelHeight + parallelMargin.top + parallelMargin.bottom)
      .append("g")
        .attr("transform", "translate(" + parallelMargin.left + "," + parallelMargin.top + ")");

    // doing something about the dimensions
    var dimension = parallelChart.selectAll(".dimension")
        .data(dimensions)
      .enter().append("g")
        .attr("class", "dimension")
        .attr("transform", function(d) { return "translate(" + xScaleParallel(d.name) + ")"; });

    // actually reading in the data
    d3.csv("states.csv", function(data) {
      dimensions.forEach(function(dimension) {
        dimension.scale.domain(dimension.type === "number"
            ? d3.extent(data, function(d) { return +d[dimension.name]; })
            : data.map(function(d) { return d[dimension.name]; }).sort());
      });

      // what's going on here?
      parallelChart.append("g")
          .attr("class", "background")
        .selectAll("path")
          .data(data)
        .enter().append("path")
          .attr("d", draw);

      // and here?
      parallelChart.append("g")
          .attr("class", "foreground")
        .selectAll("path")
          .data(data)
        .enter().append("path")
          .attr("d", draw);

      // and here?
      dimension.append("g")
          .attr("class", "axis")
          .each(function(d) { d3.select(this).call(yAxis2.scale(d.scale)); })
        .append("text")
          .attr("class", "title")
          .attr("text-anchor", "middle")
          .attr("y", -9)
          .text(function(d) { return d.name; });

      // what is happening here? something about the ordinal labels?
      var ordinal_labels = parallelChart.selectAll(".axis text")
          .on("mouseover", mouseover)
          .on("mouseout", mouseout);

      // some kind of projection thing going on now
      var projection = parallelChart.selectAll(".background path,.foreground path")
          .on("mouseover", mouseover)
          .on("mouseout", mouseout);

      // moseover function
      function mouseover(d) {
        parallelChart.classed("active", true);

        // this could be more elegant (?)
        if (typeof d === "string") {
          projection.classed("inactive", function(p) { return p.name !== d; });
          projection.filter(function(p) { return p.name === d; }).each(moveToFront);
          ordinal_labels.classed("inactive", function(p) { return p !== d; });
          ordinal_labels.filter(function(p) { return p === d; }).each(moveToFront);
        } else {
          projection.classed("inactive", function(p) { return p !== d; });
          projection.filter(function(p) { return p === d; }).each(moveToFront);
          ordinal_labels.classed("inactive", function(p) { return p !== d.name; });
          ordinal_labels.filter(function(p) { return p === d.name; }).each(moveToFront);
        }
      }

      // mouseout function
      function mouseout(d) {
        parallelChart.classed("active", false);
        projection.classed("inactive", false);
        ordinal_labels.classed("inactive", false);
      }

      // what's going on here?
      function moveToFront() {
        this.parentNode.appendChild(this);
      }
    });

    // and here?
    function draw(d) {
      return line(dimensions.map(function(dimension) {
        return [xScaleParallel(dimension.name), dimension.scale(d[dimension.name])];
      }));
    }

</script>


